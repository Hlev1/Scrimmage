package server.ai.pathFind;

/**
 * @author Harry Levick (hxl799)
 */
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import server.ai.Bot;
import shared.gameObjects.GameObject;
import shared.gameObjects.components.ComponentType;
import shared.gameObjects.components.Rigidbody;
import shared.gameObjects.players.Player;
import shared.gameObjects.weapons.Handgun;
import shared.gameObjects.weapons.MachineGun;
import shared.gameObjects.weapons.Melee;
import shared.gameObjects.weapons.Punch;
import shared.gameObjects.weapons.Sword;
import shared.gameObjects.weapons.Weapon;
import shared.handlers.levelHandler.LevelHandler;
import shared.physics.Physics;
import shared.physics.data.Collision;
import shared.physics.types.RigidbodyType;
import shared.util.maths.Vector2;
/**
 * The main file for the A* planner. - search(): This function is the core search algorithm,
 * searching for an optimal path. - optimise(): Function controlling the search and extracting plans
 * to return to the Application Programming Interface.
 */
public class AStar {

  LevelHandler levelHandler;
  ArrayList<GameObject> worldScene;
  public static final int visitedListPenalty = 100; // penalty for being in the visited-states list
  // The current best position fouond by the planner.
  public SearchNode bestPosition;
  // The furthest position found by the planner (sometimes different to the best).
  public SearchNode furthestPosition;
  // The open list of A*, contains all the unexplored search nodes.
  ArrayList<SearchNode> openList;
  // The closed list of A*
  ArrayList<SearchNode> closedList;
  // The plan generated by the planner.
  private List<boolean[]> currentPlan;
  // The enemy that we are path-finding to.
  double enemyX;
  double enemyY;
  Vector2 enemySize;
  // The bot that the path-finding is concerned with.
  Bot bot;
  Bot replicaBot; // clone of the bot to be used by search nodes

  /**
   * A SearchNode is a node in the A* search, consisting of an action (that got to the current
   * node), the world state after this action was used, and information about the parent node.
   */
  public class SearchNode {

    // The distance from the start of the search to this node.
    double distanceElapsed;
    // The optimal distance to reach the goal node AFTER simulating with the selected action.
    double remainingDistance;
    double fValue;
    // The parent node
    SearchNode parentNode;
    // The bot that the path-finding is concerned with.
    double botX;
    double botY;

    boolean visited = false;
    // The action used to get to the child node.
    boolean[] action;

    public SearchNode(boolean[] action, SearchNode parent) {
      this.parentNode = parent;
      if (parentNode != null) {
        replicaBot.setX(parentNode.botX);
        replicaBot.setY(parentNode.botY);
        // Simulate the bot with the action, using the game physics
        simulateBot(action);

        botX = replicaBot.getX();
        botY = replicaBot.getY();

        Vector2 thisPos = new Vector2(botX, botY);
        Vector2 parentPos = new Vector2(parent.botX, parent.botX);

        double distChange = thisPos.exactMagnitude(parentPos);
        this.remainingDistance = calcH(getItems(worldScene));
        // Distance from the starting node to the current node
        this.distanceElapsed = parent.distanceElapsed + distChange;

        this.fValue = /*distanceElapsed +*/ remainingDistance;
      } else {
        distanceElapsed = 0;
        replicaBot = new Bot(bot);
        replicaBot.setHolding(bot.getHolding());
        botX = replicaBot.getX();
        botY = replicaBot.getY();

        /*
        // Create a copy of the bots weapon
        Weapon botWeapon = bot.getHolding();
        Weapon cloneWeapon = null;

        if (botWeapon instanceof Handgun) {
          cloneWeapon = new Handgun((Handgun) botWeapon);
        } else if (botWeapon instanceof MachineGun) {
          cloneWeapon = new MachineGun((MachineGun) botWeapon);
        } else if (botWeapon instanceof Punch) {
          cloneWeapon = new Punch((Punch) botWeapon);
        } else if (botWeapon instanceof Sword) {
          cloneWeapon = new Sword((Sword) botWeapon);
        }
        this.nodeBot.setHolding(cloneWeapon);

         */

        // Calculate the heuristic value of the node.
        this.remainingDistance = calcH(getItems(worldScene));
        this.fValue = remainingDistance + distanceElapsed;
      }

      this.action = action;
    }

    private void simulateBot(boolean[] action) {
      for (int i = 0; i <= 4; i++) {
        replicaBot.simulateAction(action);
        replicaBot.simulateApplyInput();
        replicaBot.simulateUpdate();
        replicaBot.simulateUpdateCollision(worldScene);
      }
    }

    /**
     * Calculate the heuristic value for the node.
     * @return the distance
     */
    public double calcH(List<Weapon> allItems) {
      Vector2 botPos = new Vector2((float) botX, (float) botY);
      Vector2 enemyPos = new Vector2((float) enemyX, (float) enemyY);
      double totalH = botPos.exactMagnitude(enemyPos);

      if (!allItems.isEmpty()) {
        GameObject closestItem = findClosestItem(allItems);
        Vector2 itemPos = new Vector2((float) closestItem.getX(), (float) closestItem.getY());
        double distanceToItem = botPos.exactMagnitude(itemPos);
        // The heuristic value is the combined distance of the bot->enemy + bot->item
        // The heuristic value for the item is weighted to add preference to pick the items up.
        totalH += (distanceToItem * 2);
      }

      return totalH;
    }

    /**
     * Find all items in the world, currently only finds weapons because no such item yet
     * implemented.
     * TODO change for items.
     * @param allObjects all objects in the world
     * @return list of weapons
     */
    private List<Weapon> getItems(List<GameObject> allObjects) {
      // Collect all weapons from the world
      List<Weapon> allWeapons =
          allObjects.stream()
              .filter(w -> w instanceof Weapon && (((Weapon) w).getHolder() == null))
              .map(Weapon.class::cast)
              .collect(Collectors.toList());

      return allWeapons;
    }

    /**
     * Generate all the possible children of the node by calculating the result of all possible
     * actions.
     *
     * @return The list of children nodes.
     */
    public ArrayList<SearchNode> generateChildren() {
      ArrayList<SearchNode> list = new ArrayList<>();
      ArrayList<boolean[]> possibleActions = createPossibleActions(this);

      for (boolean[] action : possibleActions) {
        SearchNode neighbour = new SearchNode(action, this);
        if (!isInClosed(neighbour) || !isInOpen(neighbour)) {
          list.add(neighbour);
          //Physics.drawCast(neighbour.botX, neighbour.botY, neighbour.botX, neighbour.botY, "ff0000");
        }
      }

      return list;
    }

    /**
     * Finds the closest pick-upable item
     *
     * @param allItems A list of all the items in the world.
     * @return The item that is the closest to the bot
     */
    private GameObject findClosestItem(List<Weapon> allItems) {
      GameObject closestItem = null;
      Vector2 botPos = new Vector2((float) bot.getX(), (float) bot.getY());
      double targetDistance = Double.POSITIVE_INFINITY;

      for (GameObject item : allItems) {
        Vector2 itemPos = new Vector2((float) item.getX(), (float) item.getY());
        double distance = botPos.exactMagnitude(itemPos);
        // Update the target if another player is closer
        if (distance < targetDistance) {
          targetDistance = distance;
          closestItem = item;
        }
      }

      return closestItem;
    }
  }

  /**
   * Constructor
   *
   * @param bot the bot that this path-finding is concerned with.
   */
  public AStar(Bot bot, LevelHandler levelHandler) {
    this.levelHandler = levelHandler;
    this.bot = bot;
    currentPlan = new ArrayList<>();
  }

  /**
   * Main function, this calls the A* planner and extracts and returns the optimal action.
   *
   * @return The action to take.
   */
  public List<boolean[]> optimise(Player enemy) {
    // Initialise the variables needed by the search.
    initSearch(enemy);
    search();
    currentPlan = extractPlan();

    return currentPlan;
  }

  /**
   * The main search function
   */
  private void search() {
    int searchCount = 0;
    int seachCutoff  = Integer.MAX_VALUE;
    SearchNode current = bestPosition;
    closedList.add(current);
    boolean currentGood = false;

    while (openList.size() != 0 && !atEnemy(current.botX, current.botY)) {
      current = pickBestNode(openList);
      currentGood = false;

      if (!current.visited && isInClosed(current)) {
        /**
         * If the node is not directly visited, but it is close to a node that has been visited.
         * If the node is already in the closed list (i.e. has been explored before), put some
         * penalty on it and put it back into the pool.
         * Closed List -> Nodes too close to a node in the closed list are considered visited, even
         * though they are a bit different.
         */
        current.fValue += visitedListPenalty;
        current.visited = true;
        openList.add(current);
        //Physics.drawCast(current.botX, current.botY, current.botX, current.botY, "#800080");

      } else {
        currentGood = true;
        closedList.add(current);
        openList.addAll(current.generateChildren());
        searchCount++;
        //Physics.drawCast(current.botX, current.botY, current.botX, current.botY, "#00ff00");
      }

      if (currentGood)
        bestPosition = current;
      if (searchCount >= seachCutoff)
        break;

    }

  }

  /**
   * Check if the current position of the bot is close enough to the enemy to attack them, and
   * if they are in sight of the enemy.
   * @return true if the bot is close enough to the enemy.
   */
  private boolean atEnemy(double botX, double botY) {
    Vector2 botPos = new Vector2(botX, botY);
    Vector2 botPosCenter = botPos.add(bot.getTransform().getSize().mult(0.5f));
    Vector2 enemyPos = new Vector2(enemyX, enemyY);
    Vector2 enemyPosCenter = enemyPos.add(bot.getTransform().getSize().mult(0.5f));

    double dist = botPos.exactMagnitude(enemyPos);
    Melee tempMelee;

    Collision rayCast;
    // Use the worldScene of the path finding to raycast, instead of the actual gameObjects list.
    if (dist < 100f) {
      rayCast = Physics.raycastAi(botPosCenter,
          enemyPosCenter.sub(botPosCenter),
          worldScene,
          bot,
          false);

    } else {
      rayCast = Physics.raycastAi(botPosCenter,
          enemyPosCenter.sub(botPosCenter),
          worldScene,
          bot,
          false);
    }

    // If the cast is null or returns a Static RigidBody
    boolean inSight = rayCast == null || (((Rigidbody) rayCast.getCollidedObject()
        .getComponent(ComponentType.RIGIDBODY)).getBodyType() != RigidbodyType.STATIC);

    if (bot.getHolding().isGun()) {

      if (inSight)
        return true;
      else return false;

    } else { // melee weapon
      tempMelee = (Melee) bot.getHolding();
      if (dist <= tempMelee.getRange() && inSight) {
        return true;
      } else {
        return false;
      }
    }

  }

  /**
   * Returns if a node is already in the closed list
   */
  private boolean isInClosed(SearchNode node) {
    // Is the x and y coords of the given node too close the the coords of a node in the visited
    // list?
    double nodeX = node.botX;
    double nodeY = node.botY;
    double xDiff = 1.0;
    double yDiff = 1.0;

    for (SearchNode n : closedList) {

      if ((Math.abs(n.botX - nodeX) < xDiff) &&
          (Math.abs(n.botY - nodeY) < yDiff)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Returns if a node is already in the open list
   */
  private boolean isInOpen(SearchNode node) {
    double nodeX = node.botX;
    double nodeY = node.botY;
    double xDiff = 3.0;
    double yDiff = 3.0;

    for (SearchNode n : openList) {

      if ((Math.abs(n.botX - nodeX) < xDiff) &&
          (Math.abs(n.botY - nodeY) < yDiff)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Extract the plan by taking the best node and going back to the root, recording the actions
   * taken at each step.
   */
  private ArrayList<boolean[]> extractPlan() {
    ArrayList<boolean[]> actions = new ArrayList<>();

    // Just do nothing if no best position exists
    if (bestPosition == null) {
      return actions;
    }

    SearchNode current = bestPosition;
    while (current.parentNode != null) {
      actions.add(0, current.action);
      current = current.parentNode;
    }

    return actions;
  }

  /**
   * Initialise the planner
   */
  private void initSearch(Player enemy) {
    initEnemyData(enemy);
    // Take the game objects from the level handler on each search
    this.worldScene = new ArrayList<>(this.levelHandler.getGameObjects().values());
    SearchNode startPosition = new SearchNode(null, null);

    openList = new ArrayList<SearchNode>();
    closedList = new ArrayList<SearchNode>();
    openList.addAll(startPosition.generateChildren());

    bestPosition = startPosition;
    furthestPosition = startPosition;
  }

  /**
   * Raycasts downwards to find the position of the enemy where the x is the same, but they are
   * grounded.
   * @param enemy
   * @return
   */
  private void initEnemyData(Player enemy) {
    enemyX = enemy.getX();
    enemyY = enemy.getY();
    enemySize = enemy.getTransform().getSize();
  }

  private ArrayList<boolean[]> createPossibleActions(SearchNode currentPos) {
    boolean[] parentAction = currentPos.action;

    Bot nodeBot = replicaBot;
    nodeBot.setX(currentPos.botX);
    nodeBot.setY(currentPos.botY);
    boolean left = false, right = false;
    ArrayList<boolean[]> possibleActions = new ArrayList<>();
    Vector2 botPosition = new Vector2((float) currentPos.botX, (float) currentPos.botY);
    Vector2 botSize = nodeBot.getTransform().getSize();

    // Box cast to the left
    if (!Arrays.equals(parentAction, new boolean[] {false, false, true})) {

      Collision viscinityLeft = Physics.boxcast(
          botPosition.add(Vector2.Left().mult(botSize).mult(2f)),
          botSize);

      if (viscinityLeft == null ||
          ((Rigidbody) viscinityLeft.getCollidedObject().getComponent(ComponentType.RIGIDBODY))
              .getBodyType() != RigidbodyType.STATIC) {
        // If no collision, or if the collision is far away
        possibleActions.add(createAction(false, true, false));
        left = true;
      }
    } else left = true; // Cant move LEFT because the parent action was a RIGHT


    // Box cast to the right
    if (!Arrays.equals(parentAction, new boolean[] {false, true, false})) {
      Collision viscinityRight = Physics.boxcast(
          botPosition.add(Vector2.Right().mult(botSize).mult(2f)),
          botSize);

      if (viscinityRight == null ||
          ((Rigidbody) viscinityRight.getCollidedObject().getComponent(ComponentType.RIGIDBODY))
              .getBodyType() != RigidbodyType.STATIC) {

        possibleActions.add(createAction(false, false, true));
        right = true;
      }
    } else right = true; // Cant move RIGHT because the parent action was a LEFT


    // Box cast upwards
      if (nodeBot.mayJump()) { // If the bot cant jump, theres no point casting upwards
      Collision viscinityUp = Physics.boxcast(
          botPosition.add(Vector2.Up().mult(botSize)),
          botSize);
      // If no collision, or if collision is far away
      if (viscinityUp == null ||
          ((Rigidbody) viscinityUp.getCollidedObject().getComponent(ComponentType.RIGIDBODY))
              .getBodyType() != RigidbodyType.STATIC) {

        Collision viscinityUpLeft = Physics.boxcast(
            botPosition.add(Vector2.Up().mult(botSize)).add(Vector2.Left().mult(botSize)).mult(2f),
            botSize);

        Collision viscinityUpRight = Physics.boxcast(
            botPosition.add(Vector2.Up().mult(botSize)).add(Vector2.Right().mult(botSize)).mult(2f),
            botSize);

        // Just jump
        possibleActions.add(createAction(true, false, false));

        if (viscinityUpRight == null ||
            ((Rigidbody) viscinityUpRight.getCollidedObject().getComponent(ComponentType.RIGIDBODY))
                .getBodyType() != RigidbodyType.STATIC) {
          // Jump to the right
          possibleActions.add(createAction(true, false, true));
        }

        if (viscinityUpLeft == null ||
            ((Rigidbody) viscinityUpLeft.getCollidedObject().getComponent(ComponentType.RIGIDBODY))
                .getBodyType() != RigidbodyType.STATIC) {
          // Jump to the left
          possibleActions.add(createAction(true, true, false));
        }

      }

    } else {
      possibleActions.add(createAction(false, false, false));
      if (!left)
        possibleActions.add(createAction(false, true, false));
      if (!right)
        possibleActions.add(createAction(false, false, true));
    }

    return possibleActions;
  }

  private boolean[] createAction(boolean jump, boolean left, boolean right) {
    boolean[] action = new boolean[3];
    action[Bot.KEY_JUMP] = jump;
    action[Bot.KEY_LEFT] = left;
    action[Bot.KEY_RIGHT] = right;

    return action;
  }

  /**
   * Picks the node in the open list with the best f (f = h + g) value
   * @param openList the list of open nodes
   * @return the best node, from the open list
   */
  private SearchNode pickBestNode(ArrayList<SearchNode> openList) {
    SearchNode bestNode = null;
    double bestNodeF = Double.POSITIVE_INFINITY;

    for (SearchNode current : openList) {
      double f = current.fValue;
      if (f < bestNodeF) {
        bestNode = current;
        bestNodeF = f;
      }
    }
    openList.remove(bestNode);

    return bestNode;
  }


}
